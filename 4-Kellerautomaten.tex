\section[Kellerautomaten (\acs*{PDA})]{Kellerautomaten \quad\normalfont\normalsize \acf{PDA}}
\newcommand{\ConfRel}{\rhd}
\newcommand{\Zinit}{Z^\mathsf{init}}
\newcommand{\K}{\mathcal{K}}

{\color{red} TODO: Dieser rote Teil wird noch überarbeitet.

Kellerautomat $\approx$ Endlicher Automat + Kellerspeicher von unbeschränkter Größe (Stack, push down)
\paragraph*{Neu:}
\begin{itemize}
        \item Bei jedem Schritt darf der \ac{PDA} das oberste Kellersymbol inspizieren und durch ein beliebiges Kellerwort ersetzen (das neue Kellerpräfix).
        \item Der \ac{PDA} darf auf dem Keller rechnen, ohne in der Eingabe weiterzulesen ($\Eps$-Transition oder Spontantransition).
\end{itemize}
\begin{Bsp}
\label{bsp:pda-wwr}
        \begin{align}
                \Sigma &= \{0,1\} &\qquad&\text{Eingabealphabet} \notag\\
                \Gamma &= \{0,1,\bot\} &&\text{Kelleralphabet} \notag\\
                Q &= \{q_0,q_1\} &&\bot\,\hat=\,\text{Kellerbodensymbol} \notag\\
                \delta(q_0,a,Z) &= \{(q_0,aZ) \}&& a\in\{0,1\},Z\in\Gamma\\
                \delta(q_0,\Eps,Z) &= \{(q_1,Z)\} \label{eq:5.2}\\
                \delta(q_1,a,a) &= \{(q_1,\Eps)\}\\
                \delta(q_1,\Eps,\bot) &= \{(q_1,\Eps)\}
        \end{align}
  Die Übergangsfunktion $\delta$ bildet den aktuellen Zustand, das aktuelle Eingabesymbol und das aktuell oberste Kellersymbol auf Paare von Folgezustand und neuem Kellerpräfix ab.
  In diesem Beispiel ist die zurückgegebene Menge von Paaren in allen Fällen einelementig.
  Durch die $\Eps$-Transitionen ist der \ac{PDA} aber trotzdem nichtdeterministisch.

  Bei der graphischen Darstellung werden die Transitionen mit Tripeln $(a;Z;\gamma)$ beschriftet, wobei $a \in \Sigma$ das Eingabesymbol, $Z \in \Gamma$ das oberste Kellersymbol und $\gamma \in \Gamma^*$ der neue Kellerpräfix ist:
  \begin{center}
  \begin{tikzpicture}[node distance = 3cm]
    \node[state] (0) at (0,0) {$q_0$};
    \node[node distance = 1cm, left of = 0] (start) {};
    \node[state, right of = 0] (1) {$q_1$};

    \draw[->] (start) to (0);
    \draw[->, loop above] (0) to node{$a;Z;aZ$} (0);
    \draw[->] (0) to node[auto]{$\Eps;Z;Z$} (1);
    \draw[->, loop above] (1) to node[auto]{$a;a;\Eps$} (1);
    \draw[->, loop right] (1) to node[auto]{$\Eps;\bot;\Eps$} (1);
  \end{tikzpicture}
\end{center}
wobei hier $a \in \Sigma$ und $Z \in \Gamma$ gilt.

Der Automat beginnt im Startzustand $\qinit$ mit einem Kellerspeicher, der nur das Kellerbodensymbol $\Zinit$ enthält.
Er akzeptiert ein Wort, wenn er alle Eingabesymbole gelesen hat und den Keller komplett leeren konnte.
Anders als bei endlichen Automaten gibt es \emph{keine} akzeptierenden Zustände.

Die akzeptierte Sprache ist hier $L=\{ww^R \mid w\in\{0,1\}^*\}$.
\end{Bsp}
}

\begin{Def}[name={[NPDA]}]
        Ein \ac{NPDA}\footnote{Englisch: Nondeterministic Pushdown Automaton} ist ein 6-Tupel 
        $$(\Sigma,Q,\Gamma,\qinit,\Zinit,\delta).$$
        Dabei ist
        \begin{itemize}
		\item $\Sigma$ ein Alphabet, das wir auch \emph{Eingabealphabet} nennen,
                \item $Q$ eine endliche Menge, deren Elemente wir \emph{Zustände} nennen,
                \item $\Gamma$ ein Alphabet, das wir auch \emph{Kelleralphabet} nennen,
                \item $\qinit\in Q$ ein Zustand, den wir Startzustand nennen,
                \item $\Zinit\in\Gamma$ ein Zeichen, das wir \emph{Kellerbodensymbol} nennen,
                \item $\delta: Q\x(\Sigma\cup\{\Eps\})\x\Gamma \-> \mathcal{P}(Q\x\Gamma^*)$ eine Funktion, die wir \emph{Transitionsfunktion} nennen. \qedhere
        \end{itemize}
\end{Def}
Im Weiteren sei $\K=(\Sigma,Q,\Gamma,\qinit,\Zinit,\delta)$ ein \ac{NPDA}.
\begin{Def}[name={[Menge der Konfigurationen eines \acs*{NPDA}]}]
        Die Menge der \emph{Konfigurationen} von $\K$ ist $\Konf(\K) = Q\x\Sigma^*\x\Gamma^*$.\\
        Die \emph{Schrittrelation} von $\K$
  \begin{displaymath}
    \mathop{\ConfRel} \subseteq \Konf(\K) \times \Konf(\K) 
  \end{displaymath}
  ist definiert durch
        \begin{align*}
                (q,aw,Z\gamma) &\ConfRel (q',w,\beta\gamma) &&\text{falls }\delta(q,a,Z)\ni(q',\beta)\\
                (q,w,Z\gamma) &\ConfRel (q',w,\beta\gamma) &&\text{falls }\delta(q,\Eps,Z)\ni(q',\beta).
        \end{align*}

  Wir schreiben $(q,w,\gamma) \ConfRel^n (q',w',\gamma')$, wenn $\K$ in $n \in \mathbb{N}$ Schritten von Konfiguration $(q,w,\gamma)$ in Konfiguration $(q',w',\gamma')$ gelangt.

  Wir schreiben ${\ConfRel^*}$ für die reflexive, transitive Hülle von ${\ConfRel}$.
  Falls $(q,w,\gamma) \ConfRel^* (q',w',\gamma')$, so existiert also $n \in \mathbb{N}$, sodass $(q,w,\gamma) \ConfRel^n (q',w',\gamma')$.
  
        Die von $\K$ \emph{akzeptierte Sprache} ist
  \begin{displaymath}
                L(\K) = \{ w\in\Sigma^* \mid \exists q\in Q: (\qinit,w,\Zinit) \ConfRel^{\!\!*} (q,\Eps,\Eps) \}
  \end{displaymath}
  Wir nennen eine Konfiguration der Form $(q,\Eps,\Eps)$ mit $q\in Q$ eine \emph{akzeptierende Konfiguration}.
\end{Def}

\begin{Bsp*}
\datenote{6.12.2017}
  Die folgenden Schritte von $\K$ aus Beispiel \ref{bsp:pda-wwr} zeigen, dass $w = 0110 \in L(\K)$:
  \begin{displaymath}
  \begin{array}{r@{\ }ll}
    & (\qinit, 0110, \bot) \\
    \ConfRel & (\qinit, 110, 0\bot)  &\text{(,,pushen'' des Eingabesymbols $0$)}\\
    \ConfRel & (\qinit, 10, 10\bot)  &\text{(,,pushen'' des Eingabesymbols $1$)}\\
    \ConfRel & (q_1, 10, 10\bot)  &\text{($\Eps$-Übergang von $\qinit$ nach $q_1$)} \\
    \ConfRel & (q_1, 0, 0\bot)  &\text{(,,poppen'' des Eingabesymbols $1$)}\\
    \ConfRel & (q_1,\Eps, \bot) &\text{(,,poppen'' des Eingabesymbols $0$)}\\
    \ConfRel & (q_1, \Eps, \Eps) &\text{($\Eps$-Übergang zum Entfernen von $\bot$)}
    \qedhere
  \end{array}
\end{displaymath}
\end{Bsp*}

\begin{lemma}\label{lem:4.cfgToNpda}
 Zu jeder \ac{CFG} $\mathcal{G}$ gibt es einen \ac{NPDA} $\mathcal{K}$, sodass $L(\mathcal{K})=L(\mathcal{G})$.
\end{lemma}

  Zum Führen des Beweises benötigen wir das folgende Lemma.

\begin{lemma}[Mehr Keller -- mehr Möglichkeiten.]\label{lem:4.mehrKeller}
Für alle $q,q' \in Q,\enspace w \in \Sigma^*,\enspace Z \in \Gamma$ und $n \in \N$ gilt:
  \begin{displaymath}
    \text{Wenn } (q,w,Z) \ConfRel^n (q', \Eps, \Eps), \text{dann } \forall v \in \Sigma^*, \gamma \in \Gamma^*: (q, wv, Z\gamma) \ConfRel^n (q', v, \gamma).
    \qedhere
  \end{displaymath}
\end{lemma}
\begin{proof}
Übungsaufgabe.
\end{proof}


  
\begin{proof}[von \autoref{lem:4.cfgToNpda}]
Sei $\mathcal{G} = (\Sigma,N,P,S)$ eine kontextfreie Grammatik für $L$ in \ac{CNF}.
                Definiere einen \ac{NPDA} $\mathcal{K} = (\Sigma,Q,\Gamma,\qinit,\Zinit,\delta)$ durch:
                \begin{itemize}
                        \item $Q = \{\qinit\}$ 
                        \item $\Gamma = \Sigma\overset.\cup N$
                        \item $\Zinit = S$
                        \item $\delta(\qinit,a,a) = \{(\qinit,\Eps)\} $ für $ a\in\Sigma$
                        \item $\delta(\qinit,\Eps,A) = \{(\qinit,\alpha)\}$ für $A\to\alpha\in P$
                \end{itemize}
Wir zeigen nun, dass $L(\K) = L(\mathcal{G})$.
\begin{itemize}
 \item Beweisrichtung ``$\supseteq$''
 
 Sei $w\in L(\mathcal{G})$, dann gilt $S\stackrel{*}{\vdash} w$.
 Wir wollen zeigen dass $(\qinit, w, S) \ConfRel^* (\qinit, \Eps, \Eps)$ folgt und beweisen dafür via vollständige Induktion über die Länge der Ableitung die folgende stärkere Eigenschaft.
     \begin{displaymath}
      \forall A \in N: \text{ wenn } A \stackrel{*}{\vdash} w, \text{dann } (\qinit, w, A) \ConfRel^* (\qinit, \Eps, \Eps)
    \end{displaymath}
  I.A.: $n=1$: Es gibt nur zwei Arten von Regeln, die für Ableitungen der Länge 1 in Frage kommen:
  \begin{itemize}
        \item $S \to \Eps$.
        Per Konstruktion gilt $(\qinit, \Eps) \in \delta(\qinit, \Eps, S)$ und somit $(\qinit, \Eps, S) \ConfRel (\qinit, \Eps, \Eps)$.
      \item $A \to a$, $a \in \Sigma$.
        Per Konstruktion gilt $(\qinit, a) \in \delta(\qinit, \Eps, A)$ und $(\qinit, \Eps) \in \delta(\qinit, a, a)$.

        Somit gilt $(\qinit, a, A) \ConfRel (\qinit, a, a) \ConfRel (\qinit, \Eps, \Eps)$.
   \end{itemize}
   
   I.S.: $n\rightsquigarrow n+1$: In diesem Fall verwendet der erste Ableitungsschritt eine Regel der Form $\pi = A \to BC$ mit $B,C \in N$.
   Wir betrachten den zugehörigen Ableitungsbaum $\mathcal{T} = \pi(\mathcal{T}_1, \mathcal{T}_2)$, $\mathcal{T}_1 \in \operatorname{Abl}(B)$, $\mathcal{T}_2 \in \operatorname{Abl}(C)$, $w = Y(\mathcal{T}_1)Y(\mathcal{T}_2)$.

        Per Konstruktion gilt $(\qinit, BC) \in \delta(\qinit, \Eps, A)$. 

        Ferner gilt per I.V., dass $(\qinit, Y(\mathcal{T}_1), B) \ConfRel^* (\qinit, \Eps, \Eps)$ und $(\qinit, Y(\mathcal{T}_2), C) \ConfRel^* (\qinit, \Eps, \Eps)$.

        Mit \autoref{lem:4.mehrKeller} folgt schließlich:
        \begin{align*}
          (\qinit, w, A) = (\qinit, Y(\mathcal{T}_1)Y(\mathcal{T}_2), A) &\ConfRel (\qinit, Y(\mathcal{T}_1)Y(\mathcal{T}_2), BC) \\
          &\ConfRel^* (\qinit, Y(\mathcal{T}_2), C) \\
          &\ConfRel^* (\qinit, \Eps, \Eps).
        \end{align*}
 \item Beweisrichtung  ``$\subseteq$''
 
 Sei $w\in L(\K)$, dann gilt $(\qinit, w, S) \ConfRel^* (\qinit, \Eps, \Eps)$.
 Wir wollen $S \stackrel{*}{\vdash} w$ folgern und beweisen dafür via vollständige Induktion über die Anzahl der Berechnungsschritte $n$ die folgende Aussage:
     \begin{displaymath}
      \forall n \in \mathbb{N}: \forall w \in \Sigma^*, \alpha \in \Gamma^*: \text{ wenn } (\qinit, w, \alpha) \ConfRel^n (\qinit, \Eps, \Eps), \text{dann } \alpha \stackrel{*}{\vdash} w
    \end{displaymath}
    
    \begin{description}
    \item[I.A.] $n = 0$.
      $w = \Eps$, $\alpha = \Eps$: Es gilt $\Eps \stackrel{*}{\vdash} \Eps$.

  \item[I.S.] $n > 0$, $\alpha = Z\alpha'$: Es gilt
    $(\qinit,w,Z\alpha') \ConfRel (\qinit, w', \beta\alpha') \ConfRel^{n-1} (\qinit, \Eps, \Eps)$, \linebreak
    $\delta(\qinit, x, Z) \ni (\qinit, \beta)$, $x \in \Sigma \cup \{\varepsilon\}$.

    Es gibt zwei Fälle für $Z$:
    \begin{itemize}
    \item $Z = a$ für $a \in \Sigma$.
%
      Es folgt $\beta = \Eps$, $w = aw'$ und $x = a$.

      Per I.V.\ gilt $\alpha' \stackrel{*}{\vdash} w'$ und somit auch $\alpha = a\alpha' \stackrel{*}{\vdash}aw' = w$.
    \item $Z = A$ mit $A \to \beta \in P$.
%
      Es folgt $w = w'$ und $x = \varepsilon$.

      Per I.V.\ gilt $\beta\alpha' \stackrel{*}{\vdash} w'$ und somit auch $A\alpha \vdash \beta\alpha' \stackrel{*}{\vdash} w' = w$.
      \qedhere
    \end{itemize}
    \end{description}
\end{itemize}
\end{proof}

Bei einem \ac{NPDA} nehmen wir in jedem Schritt ein Zeichen vom Kellerspeicher herunter,
aber dürfen beliebig viele Symbole auf den Kellerspeicher zurücklegen.
Was wäre, wenn die Höhe des Kellers pro Schritt höchstens um eins größer werden könnte?
Verlören wir dadurch nur Komfort oder könnten wir dadurch weniger Sprachen akzeptieren?

Das folgende Lemma beantwortet diese Frage.
\begin{lemma}\label{lem:4.limitStackIncrease}
        Zu jedem \ac{NPDA} gibt es einen äquivalenten \ac{NPDA}, bei dem
        für alle $q,q\in Q, Z\in\Gamma, \gamma\in\Gamma^*, x\in\Sigma\cup\{\Eps\}$
        gilt: Falls $(q',\gamma)\in\delta(q,x,Z)$, dann $|\gamma| \le 2$.
\end{lemma}
\begin{proof}
        Sei $(q',\gamma)\in\delta(q,x,Z)$ mit $\gamma = Z_n\dots Z_1$ für $n>2$:
        \begin{itemize}
        \item   neue Zustände $q_2\dots q_{n-1}$
        \item Ersetze $(q',\gamma)$ durch $(q_2, Z_2Z_1)$
        \item Definiere $\delta(q_i, \Eps, Z_i) = \{ (q_{i+1}, Z_{i+1}Z_i) \}$, für $2\le i < n-1$
        \item Definiere $\delta(q_{n-1}, \Eps, Z_{n-1}) = \{ (q', Z_nZ_{n-1}) \}$
        \end{itemize}
        Wiederhole bis alle Transitionen die gewünschte Form haben.
        Die Sprache des \ac{NPDA} ändert sich durch diese Transformation nicht (ohne Beweis).\qedhere
\end{proof}


\begin{lemma}\label{lem:4.npdaToCfg}
\datenote{8.12.2017}
 Zu jedem \ac{NPDA} $\mathcal{K}$ gibt es eine \ac{CFG} $\mathcal{G}$, sodass $L(\mathcal{K})=L(\mathcal{G})$.
\end{lemma}

\begin{proof}
 Ohne Einschränkung (\autoref{lem:4.limitStackIncrease}) sei $\mathcal{K} = (Q, \Sigma, \Gamma, \qinit, \Zinit, \delta)$ ein \ac{NPDA} mit $|\gamma| \le 2$ für alle $(q', \gamma) \in \delta(q, x, Z), q, q' \in Q, x \in \Sigma \cup \{\Eps\}, Z \in \Gamma$.

    Definiere $\mathcal{G} = (\Sigma, N, P, S)$ mit $N = (Q \times \Gamma \times Q) \cup \{S\}$ und $P=P_S\cup P_0\cup P_1\cup P_2$ mit:
    \begin{align*}
    P_S &= \{S \to [\qinit, \Zinit, q']\mid q'\in Q\}, \\[1mm]
    %
    P_0 &= \{ [q, Z, q'] \to x \mid (q', \Eps)\in \delta(q, x, Z), x \in \Sigma \cup \{\Eps\} \}, \\[1mm]
    %
    P_1 &= \{[q, Z, q'] \to x[q'', Z', q'] \mid (q'', Z')\in \delta(q, x, Z), x \in \Sigma \cup \{\Eps\}\}, \\[1mm]
    %
    P_2 &= \{[q, Z, q'] \to x[q_1,Z_1,q_2][q_2, Z_2, q'] \mid (q_1, Z_1Z_2)\in\delta(q, x, Z), q_2 \in Q, x \in \Sigma \cup \{\Eps\} \}
    \end{align*}
    
    Dabei unterscheiden $P_0$, $P_1$ und $P_2$ die Fälle, dass der Stack kleiner wird ($P_0$), gleich hoch bleibt ($P_1$) oder größer wird ($P_2$).
    
    Die dieser Konstruktion zugrunde liegende Idee wird durch die folgende Eigenschaft beschrieben:
      \begin{equation}\label{eq:npdaToCfgProp}
        [q,Z,q']\stackrel{n}{\vdash} w \text{ gdw } (q,w,Z) \ConfRel^n (q',\Eps,\Eps)
      \end{equation}
    In Worten: Wir können vom Nichtterminalsymbol $[q,Z,q']$ das Wort $w$ genau dann in $n$ Schritten ableiten,
    wenn der \ac{NPDA} die Konfiguration $(q,w,Z)$ in $n$ Schritten in eine akzeptierende Konfiguration mit Zustand $q'$ überführen kann.
    
    Beispiel:
    
    \ac{NPDA} für $L_\text{centered3}:=\{0^n10^n \mid n\in\N, n > 0 \}\subseteq\{0,1\}^*$:
    
\newcommand{\el}[3]{{\color{red!70!black}#1};{\color{blue!70!black}#2};{\color{blue!70!black}#3}}
    \begin{center}
    \begin{tikzpicture}
 
    \node[circle,draw] (q0) at (-1.5,0) {$q_0$};
    \node[circle,draw] (q1) at (1.5,0) {$q_1$};
    
    \draw[->] (-2.5,0.1) to  (q0) ;
    
    \draw[->] (q0) edge node[auto] {\el{1}{X}{X}} (q1) ;
    
    \draw[->,in=100, out=120, looseness=22, pos=0.50] (q0) edge node[auto] {\el{0}{X}{XX}} (q0) ;
    \draw[->,in=260, out=240, looseness=22, pos=0.50] (q0) edge node[left] {\el{0}{\#}{X\#}} (q0) ;
    
    \draw[->,in=50, out=70, looseness=22, pos=0.50] (q1) edge node[right] {\el{0}{X}{$\varepsilon$}} (q1) ;
    \draw[->,in=-70, out=-50, looseness=22, pos=0.45] (q1) edge node[right] {\el{$\varepsilon$}{\#}{$\varepsilon$}} (q1) ;
    \end{tikzpicture}
    \end{center}
    
    $010$ wird akzeptiert, weil
        $(q_0, 010, \#)\ConfRel (q_0, 10, X\#)\ConfRel (q_1, 0, X\#)\ConfRel (q_1, \Eps, \#)\ConfRel (q_1, \Eps, \Eps)$.
    
    \begin{center}
    \vspace*{-1.5\baselineskip}
    \begin{minipage}[t]{55mm}
    \begin{align*}
    P_S = \{ 
    & S \to [q_0, \#, q_0]\\
    & S \to [q_0, \#, q_1] 
    \}\\
    \\
    % \end{align*}
    % \begin{align*}
    P_0 = \{ 
    & [q_1, X, q_1] \to 0\\
    & [q_1, \#, q_1] \to \Eps
    \}\\
    \\
    % \end{align*}
    % \begin{align*}
    P_1 = \{ 
    & [q_0, X, q_0] \to 1[q_1, X, q_0]\\
    & [q_0, X, q_1] \to 1[q_1, X, q_1]
    \}
    \end{align*}
    \end{minipage}
    \begin{minipage}[t]{70mm}
    \begin{align*}
    P_2 = \{ 
    & [q_0, \#,q_0] \to 0[q_0, X, q_0] [q_0 \#, q_0]\\
    & [q_0, \#,q_0] \to 0[q_0, X, q_1] [q_1 \#, q_0]\\
    & [q_0, \#,q_1] \to 0[q_0, X, q_0] [q_0 \#, q_1]\\
    & [q_0, \#,q_1] \to 0[q_0, X, q_1] [q_1 \#, q_1]\\
    % 
    & [q_0, X,q_0] \to 0[q_0, X, q_0] [q_0 X, q_0]\\
    & [q_0, X,q_0] \to 0[q_0, X, q_1] [q_1 X, q_0]\\
    & [q_0, X,q_1] \to 0[q_0, X, q_0] [q_0 X, q_1]\\
    & [q_0, X,q_1] \to 0[q_0, X, q_1] [q_1 X, q_1]
    \}
    \end{align*}
    \end{minipage}
    \end{center}
    
    Ableitungsbaum für $010$:
    
    \begin{center}
    \vspace*{-\baselineskip}
    \begin{tikzpicture}
 
    \node[] (root) at (0,0) {$S \to [q_0, \#, q_1]$};
    
    \node[] (m) at (0, -1.5) {$[q_0, \#,q_1] \to 0[q_0, X, q_1] [q_1, \#, q_1]$};
    
    \node[] (ml) at (-2, -3) {$[q_0, X, q_1] \to 1[q_1, X, q_1]$};
    \node[] (mr) at (2, -3) {$[q_1, \#, q_1] \to \Eps$};
    
    \node[] (mlm) at (-2, -4.5) {$[q_1, X, q_1] \to 0$};
    
    
    
    \draw[] (root) to (m) ;
    \draw[] (m) to (ml) ;
    \draw[] (m) to (mr) ;
    \draw[] (ml) to (mlm) ;
    
    \end{tikzpicture}
    \end{center}
    
    Offensichtlich folgt aus dieser Eigenschaft $L(\mathcal{G}) = L(\mathcal{K})$, da wir vom Startsymbol $S$ genau die Nichtterminalsymbole der Form
    $[\qinit, \Zinit, q']$ ableiten können und der \ac{NPDA} genau die Wörter $w$ akzeptiert, für die  $(\qinit, w, \Zinit)$ in eine akzeptierende Konfiguration überführt werden kann.
    
    Es bleibt zu zeigen, dass die Eigenschaft \eqref{eq:npdaToCfgProp} gilt.
    Für den Fall $n=1$ folgt die Eigenschaft direkt aus den $P_0$-Regeln (und der Tatsache, dass keine der anderen Regeln ein einzelnes Symbol oder $\Eps$ ableiten kann).
    
    \begin{itemize}
     \item Beweisrichtung ``$\Rightarrow$''
     Wir zeigen diese Richtung via vollständige Induktion über die Anzahl der Ableitungsschritte.
     \begin{description}
      \item[I.A.] $n=1$: Folgt wie oben erwähnt aus den $P_0$-Regeln.
      \item[I.S.] $n\rightsquigarrow n+1$:
      Sei $[q,Z,q']\vdash\alpha\stackrel{n}{\vdash} w$ eine Ableitung für $w$. Für den ersten Ableitungsschritt kommen zwei Fälle in Frage:
      \begin{itemize}
      \item Fall 1: $\alpha$ hat die Form $x[q'', Z', q']$ ($[q,Z,q']\rightarrow\alpha \in P_1$).
      
	  Es folgt $w = xw'$ für ein $w'$ mit $[q'', Z', q']\stackrel{n}{\vdash} w'$.
	  
	  Nach I.V.\ gilt nun, dass $(q'', w', Z') \ConfRel^n (q',\Eps,\Eps)$.
	  
	  Nach Konstruktion gilt $\delta(q, x, Z) \ni (q'', Z'), q'' \in Q, x \in \Sigma \cup \{\Eps\}$ und somit
	  $(q, w, Z) \ConfRel (q'', w', Z') \ConfRel^n (q',\Eps,\Eps)$.
      \item Fall 2: $\alpha$ hat die Form $x[q_1,Z_1,q_2][q_2, Z_2, q']$ ($[q,Z,q']\rightarrow\alpha \in P_2$).
      
      Es gibt also einen Ableitungsbaum $\mathcal{T} = \pi(\mathcal{T}_1,\mathcal{T}_2)$, mit $\mathcal{T}_1 \in \operatorname{Abl}([q_1, Z_1, q_2])$ und $\mathcal{T}_2 \in \operatorname{Abl}([q_2, Z_2, q'])$, sodass $w = xY(\mathcal{T}_1)Y(\mathcal{T}_2)$.
      
      Es gilt also $[q_1, Z_1, q_2]\stackrel{k_1}{\vdash} Y(\mathcal{T}_1)$ und 
      $[q_2, Z_2, q']\stackrel{k_2}{\vdash} Y(\mathcal{T}_2)$ für $k_1,k_2\in\N$, sodass $k_1+k_2=n$.
      
          Per I.V.\ folgt
          \begin{displaymath}
            (q_1, Y(\mathcal{T}_1), Z_1) \ConfRel^{k_1} (q_2, \Eps, \Eps).
          \end{displaymath}
          Mit \autoref{lem:4.mehrKeller} folgt auch
          \begin{displaymath}
            (q_1, Y(\mathcal{T}_1)Y(\mathcal{T}_2), Z_1Z_2) \ConfRel^{k_1} (q_2, Y(\mathcal{T}_2), Z_2).
          \end{displaymath}
          

      Auch hier können wir wieder I.V.\ anwenden und erhalten:
          \begin{displaymath}
            (q_2, Y(\mathcal{T}_2), Z_2) \ConfRel^{k_2} (q', \Eps, \Eps)
          \end{displaymath}
          
                    Somit gilt:
          \begin{displaymath}
            (q, \underbrace{xY(\mathcal{T}_1)Y(\mathcal{T}_2)}_{w}, Z) \ConfRel (q_1, Y(\mathcal{T}_1)Y(\mathcal{T}_2), Z_1Z_2) \ConfRel^{k_1} (q_2, Y(\mathcal{T}_2), Z_2) \ConfRel^{k_2} (q', \Eps, \Eps)
          \end{displaymath}
      \end{itemize}
      
     \end{description}

    \end{itemize}
    
    \item Beweisrichtung ``$\Leftarrow$''
     Wir zeigen diese Richtung via vollständige Induktion über die Anzahl der Berechnungsschritte des \ac{NPDA}.
     \begin{description}
      \item[I.A.] $n=1$: Folgt wie oben erwähnt aus den $P_0$-Regeln.
      \item[I.S.] $n\rightsquigarrow n+1$:
      
      Sei $(q,w,Z) \ConfRel^{n+1} (q',\Eps,\Eps)$ eine Berechnung für $w$. Da wir annehmen, 
      dass der \ac{NPDA} in einem Schritt höchstens zwei Symbole auf den Stack legen darf, kommen für den ersten Berechnungsschritt nur zwei Fälle in Frage:
      \begin{itemize}
      \item Fall 1: $(q,w,Z)\ConfRel (q'', w',Z')$ mit $w=xw'$ für $x\in\Sigma\cup\{\Eps\}$
      
      Aus $(q'', w',Z')\ConfRel^n (q',\Eps,\Eps)$ folgern wir mit I.V.\
      $[q'', Z',q']\vdash^n w'$.
      Nach Konstruktion können wir $[q,Z,q']\vdash x [q'', Z',q']$ ableiten.

      
      \item Fall 2: $(q,w,Z)\ConfRel (q_1, w',Z_1Z_2)$ mit $w=xw'$ für $x\in\Sigma\cup\{\Eps\}$

            Aus $(q_1, w',Z_1Z_2)\ConfRel^n (q',\Eps,\Eps)$ folgern wir:
      $\exists k_1,k_2\in\N, \; q_2\in Q, \; w_1,w_2\in \Sigma^*$, sodass gilt:
      \begin{enumerate}
      \item $k_1+k_2=n$
      \item $w'=w_1w_2$
      \item $(q_1, w',Z_1Z_2)\ConfRel^{k_1} (q_2, w_2,Z_2)$
      \item $(q_2, w_2,Z_2)\ConfRel^{k_2} (q',\Eps,\Eps)$
      \end{enumerate}
      
      Aus 3.\ folgern wir $(q_1, w_1,Z_1)\ConfRel^{k_1} (q_2, \Eps,\Eps)$ und mit I.V.\
      $[q_1, Z_1, q_2] \vdash^{k_1} w_1$.
      
      Aus 4.\ folgern wir mit I.V.\ $[q_2, Z_2, q'] \vdash^{k_2} w_2$.
      
      Es gibt also einen Ableitungsbaum $\mathcal{T} = \pi(\mathcal{T}_1,\mathcal{T}_2)$, mit $\mathcal{T}_1 \in \operatorname{Abl}([q_1, Z_1, q_2])$ und $\mathcal{T}_2 \in \operatorname{Abl}([q_2, Z_2, q'])$, sodass $w = xY(\mathcal{T}_1)Y(\mathcal{T}_2)$.
      
      Somit gibt es auch eine Ableitung
      \begin{equation*}
      [q, Z, q'] \vdash x[q_1,Z_1,q_2][q_2, Z_2, q'] \vdash^{k_1+k_2} xw_1w_2. \qedhere
      \end{equation*}
      \end{itemize}
     \end{description}
\end{proof}








\hide{

\begin{Satz}\label{satz:5.1}
  \begin{align*}
                L \in \ac{CFL}  \text{ gdw } L =L(M) \text{ für einen \ac{NPDA} $M$}
  \end{align*}
\end{Satz}
\datenote{21.12.16}
\begin{proof}\hfill
        \begin{itemize}
        \item \ac{CFG} zu \ac{NPDA}:


  \item \ac{NPDA} zu \ac{CFG}:

    Zunächst zeigen wir, dass es genügt, \ac{NPDA}s zu betrachten, die bei jeder Transition Wörter der maximalen Länge $2$ auf den Keller schreiben:



\end{itemize}
  
\end{proof}

\begin{Def}[name={[DPDA]}]
        Ein \ac{DPDA} ist ein Tupel $(\underbrace{Q,\Sigma,\Gamma,\qinit,\Zinit}_{\text{wie gehabt}},\delta,F)$
        \vspace{-1em}
        \begin{itemize}
        \item $F\subseteq Q$ akzeptierende Zustände
        \item $\delta: Q\x (\Sigma\cup\{\Eps\})\x \Gamma \-> \mathcal{P}(Q\x \Gamma^*)$ wobei für alle $q\in Q,a\in\Sigma,Z\in\Gamma$ gelten muss, dass
        $|\delta(q,a,Z)| + |\delta(q,\Eps,Z)| \leq 1$
        \item Die Schrittrelation ,,$\ConfRel$'' ist definiert wie bei \ac{NPDA}s.
        \item $L(M) = \{w\in\Sigma^* \mid (\qinit,w,\Zinit) \ConfRel^* (q',\Eps,\gamma) \land q'\in F \}$ \qedhere
        \end{itemize}
\end{Def}

\begin{lemma}[name={[\acs*{DPDA}, der gesamte Eingabe verarbeitet]}]
        \label{lem:DPDA ges. Eingabe}
        Zu jedem \ac{DPDA} $M$ gibt es einen äquivalenten \ac{DPDA} $M'$, der
        jede Eingabe bis zum Ende liest.
\end{lemma}
\draftnote{23.12.16}
\begin{proof}

  Sei $M = (Q, \Sigma, \Gamma, \qinit, \Zinit, \delta, F)$. 
  Zwei Möglichkeiten, warum $M$ nicht die gesamte Eingabe verarbeiten:
  Die Transitionsrelation ist nicht total \footnote{d.h. es gibt zwei Konfigurationen $a$, $b$
  so dass $a \not \Rightarrow^* b$} oder der Automat bleibt bei
  leerem Keller stecken.

  Abhilfe: Führe einen Senkzustand ein, auf dem $M'$ weiterrechnet, wenn $M$ nicht mehr weiterrechnen kann. Definiere dazu $M' = (Q', \Sigma, \Gamma', {\qinit}', {\Zinit}', \delta', F')$ mit
  \begin{align*}
  Q' &= Q \cup \{{\qinit}', q_s\} \text{ neue Zustände: ${\qinit}'$ neuer Startzustand und $q_s$ Senkzustand} \\
  F' &= F \\
  \Gamma' &= \Gamma \cup \{{\Zinit}'\} \text{ neues Kellerbodensymbol}
  \end{align*}
  und Transitionsfunktion $\delta'$ gegeben durch
  \[\delta' ({\qinit}', \varepsilon, {\Zinit}') = \{ (\qinit, \Zinit{\Zinit}') \} \]
  \begin{itemize}
  \item Transition totalisieren: Für alle $q\in Q$, $Z \in \Gamma$\\
    \begin{align*}
      \delta' (q, \varepsilon, Z) &=
      \begin{cases}
        \delta (q, \varepsilon, Z) & \text{falls
        }\ne\emptyset\vee\exists a\in\Sigma, \delta (q, a, Z)\ne \emptyset \\
        \{ (q_s, Z) \} & \text{sonst}
      \end{cases} \\
      \delta' (q, a, Z) &=
      \begin{cases}
        \delta (q, a, Z) & \text{falls }\ne\emptyset\vee\delta (q,
        \varepsilon, Z) \ne \emptyset \\
        \{ (q_s, Z) \} & \text{sonst}
      \end{cases}
    \end{align*}
    Intuition: Wenn $\delta(q, a, Z) = \emptyset$ und ein $\epsilon$-Übergang ebenfalls ausscheidet, kann das Wort von $M$ nicht weiter abgearbeitet werden. $M'$ geht nun in Senkzustand $\qinit$ und arbeitet dort weiter. Analog für $\delta(q, \epsilon, Z)$.
  \item Kellerunterlauf: $M$ hat $\Zinit$ abgeräumt, so dass ${\Zinit}'$
    sichtbar geworden ist. Füge eine $\epsilon$-Transition in
     Senkzustand $q_s$ hinzu, indem man für alle $q\in Q$ definiere:\\
    \[\delta' (q, \varepsilon, {\Zinit}') = \{ (q_s, {\Zinit}') \} \]
  In $q_s$ kann der Automat nun für alle $a\in\Sigma$, $Z\in \Gamma'$ abarbeiten:\\
    \[\delta' (q_s, a, Z) = \{ (q_s, Z) \}\]   %TODO warum Z und nicht {\Zinit}' ?!
    Bemerke, dass $\qinit \not \in F'$, da ein Kellerunterlauf
    das Akzeptieren des eingelesen Wortes ausschliesst.
  \end{itemize}

  Es verbleibt zu zeigen, dass $\forall w\in \Sigma^*$ $\exists q\in Q'$
  $\gamma\in\Gamma'^*$ so dass $({\qinit}', w, {\Zinit}') \ConfRel^* (q,
  \varepsilon, \gamma)$. (Induktion über $w$) Weiter ist zu zeigen,
  dass $L (M) = L (M')$.
\end{proof}

\begin{Satz}[name={[Abgeschlossenheit der deterministischen \acs*{CFL}]}]
        Die deterministischen \ac{CFL} sind unter Komplement abgeschlossen.
\end{Satz}
\begin{proof}
  Sei $L=L(M)$ für \ac{DPDA} $M$. Nach \autoref{lem:DPDA ges. Eingabe} liest $M$ die komplette Eingabe. 

  Konstruiere \ac{DPDA} $M'$, s.d. $ L(M') = \overline{L}$. 
  Definiere dazu $Q'= q \times \{0,1,2\}$. Bedeutung des zusätzlichen ,,Flags'' $\in \{0,1,2\}$:
  \begin{itemize}
  \item $0$: seit Lesen des letzten Symbols $\epsilon \vee a \in \Sigma$ wurde kein akzeptierender Zustand durchlaufen
  \item $1$: seit Lesen des letzten Symbols wurde mindestens ein
    akzeptierender Zustand durchlaufen 
  \item $2$: markiert einen akzeptierenden Zustand in $M'$.
  \end{itemize}
        
  $F'=F\x \{2\}$

  Definiere Hilfsfunktion $\mathit{final}:Q\to \{0,1\}$ durch 
  \begin{displaymath}
    \mathit{final} (q) =
    \begin{cases}
      0 & q\notin F \\ 1 & q \in F
    \end{cases}
  \end{displaymath}
  \begin{align*}
    {\qinit}' &= (\qinit,\mathit{final} (\qinit))
  \end{align*}
  Für alle $q \in Q$, $Z\in\Gamma$.
  
  Falls $\delta(q,\Eps,Z) = \{(q',\gamma)\}$, dann
  \begin{align*}
    \delta'((q,0),\Eps,Z) &= ((q',\mathit{final} (q')),\gamma)
    \\
    \delta'((q,1),\Eps,Z) &= ((q',1),\gamma)
  \end{align*}
  Falls $\delta(q,a,Z) = \{(q',\gamma)\}$, dann
  \begin{align*}
    \delta'((q,0), \Eps, Z) &= \{ ((q,2), Z) \} \\
    \delta'((q,2), a, Z) &=((q',\mathit{final} (q')), \gamma)
    \\
    \delta'((q,1), a, Z) &=
    ((q',\mathit{final} (q')), \gamma)
    \\ \tag*{\qedhere}    %TODO Intuition?
  \end{align*}
\end{proof}
\begin{Satz}
    Die deterministischen \ac{CFL} sind \textbf{nicht} unter Vereinigung und Durchschnitt abgeschlossen.
\end{Satz}
\begin{proof}
    Betrachte
    \begin{align*}
        L_1 &= \{ a^nb^nc^m \mid n, m \ge 1 \} \\
        L_2 &= \{ a^mb^nc^n \mid n, m \ge 1 \}
    \end{align*}
    Sowohl $L_1$ als auch $L_2$ sind DCFL, aber $L_1 \cap L_2 = \{ a^nb^nc^n \mid n \ge 1\}$ ist nicht kontextfrei.
    
    DCFL ist nicht abgeschlossen unter Vereinigung. Angenommen doch: Seien $U, V$ DCFL. Dann sind auch $\overline{U}$ und $\overline{V}$ DCFL. Bei Abschluss unter Vereinigung wäre $\overline{U} \cup \overline{V}$ eine DCFL und somit auch $\overline{\overline{U} \cup \overline{V}} = U \cap V$, ein Widerspruch gegen den ersten Teil.
\end{proof}
\begin{Satz}
    DCFL ist abgeschlossen unter Schnitt mit REG.
\end{Satz}
\begin{proof}
    Sei $L$ DCFL und $R$ regulär.
    Konstruiere das Produkt aus einem DPDA für $L$ und einem DFA für $R$.
    Offenbar ist das Ergebnis ein DPDA, der $L\cap R$ akzeptiert. \footnote{
    Intution des Beweis: Konstruiere Produktautomaten, der akzeptiert gdw. der DFA und NDPA akzeptieren. Idee: Definiere Tupel $(q_1, q_2)$, DPDA arbeitet auf $q_1$, DFA arbeitet auf $q_2$. Beispielsweise werden $\epsilon$-Übergänge des DPDA nur auf der ,,DPDA-Seite'' d.h. auf $q_1$ abgearbeitet, ohne Beeinflussung von $q_2$.
    }

    $L = L (M_1)$ mit $M_1 = (Q_1, \Sigma, \Gamma, q_{01}, \Zinit,
    \delta_1, F_1)$ \ac{DPDA}

    $R = L (M_2)$ mit $M_2 = (Q_2, \Sigma, q_{02}, \delta_2, F_2)$
    \ac{DFA}

    Konstruiere $M'= (Q, \Sigma, \Gamma, \qinit, \Zinit, \delta, F)$ mit
    \begin{itemize}
    \item $Q = Q_1 \times Q_2$
    \item $\qinit = (q_{01}, q_{02})$
    \item $F = F_1  \times F_2$
    \item Falls $\delta_1 (q_1, \varepsilon, Z) = \{(q_1', \gamma)\}$, dann gilt für alle $q_2\in Q_2$: 
      \[ \delta ((q_1, q_2), \varepsilon, Z)
      = \{((q_1', q_2), \gamma)\} \text{.     (Ansonsten leer)} \]
    \item Falls $\delta_1 (q_1, a, Z) = \{(q_1', \gamma)\}$, dann gilt für alle $q_2\in Q_2$: 
      \[ \delta ((q_1, q_2), a, Z) =
      \{((q_1', \delta_2 (q_2, a)), \gamma)\} \text{   (Ansonsten leer)} \]
    \end{itemize}
    Zu zeigen ist noch $L (M') = L (M_1) \cap L (M_2)$.
\end{proof}
\begin{Satz}
    Sei $L$ DCFL und $R$ regulär.
    Es ist entscheidbar, ob $R=L$, $R\subseteq L$ und $L=\Sigma^*$.
\end{Satz}
\begin{proof}
    Es gilt $R\subseteq L$ gdw.\ $R \cap \overline{L} = \emptyset$.
    
    Weiter ist $R = L$ gdw.\ $R\subseteq L$ und $L \subseteq R$. Für den zweiten Teil betrachte $L\cap \overline{R}$.
    
    Für kontextfreie Sprachen ist $L\ne \emptyset$ entscheidbar, also betrachte $L=\Sigma^*$ gdw.\ $\overline{L}=\emptyset$.
\end{proof}

\begin{Satz} \textbf{DPDA Äquivalenzproblem}
    Seien $L_1, L_2$ DCFL. Dann ist $L_1 = L_2$ entscheidbar.
\end{Satz}

\begin{proof}
    Siehe Senizergues (2000) und Stirling (2001).
\end{proof}

Wir betrachten zum Ende des Kapitels noch eine praktische Fragestellung: Wie sieht man einer CFL an, dass sie von einem DPDA akzeptierbar ist?

Sei $\mathcal{G} = (\Sigma, N, P, S)$.
Wir können nach Satz \ref{satz:5.1} einen \ac{PDA} für $\mathcal{G}$ konstruieren, mit
\begin{align*}
  \delta(q, a, a) &= \{(q, \Eps)\} \quad a \in \Sigma \\
  \delta(q, \Eps, A) &= \{(q, \beta)  \mid A \to \beta \in P\}
\end{align*}
Die Transitionen für Eingabezeichen $a \in \Sigma$ sind deterministisch.
Die $\Eps$-Transitionen sind es nicht unbedingt.

Die Idee ist nun, den Automaten mit einem Symbol Lookahead \footnote{Das Problem ist, dass ein deterministischer \ac{PDA} nicht ,,alle mögl. Regeln gleichzeitig ausprobieren'' kann, so wie ein NDPA. Möchte der Automat ein Eingabesymbol $a$ matchen und kann aktuell mehrere Produktionen anwenden, müsste er in die Zukunft sehen können, um diejenige zu wählen, die das gewünschte $a$ an erster Position erzeugt. Diesen ,,Blick in die Zukunft'' gewähren die $first(A)$ Mengen: Sie geben für jedes Nichtterminal $A$ an, welche Terminale $a \in \Sigma$ als Präfix von $yield(A)$ auftreten können.} 
erweitern. Dieses Symbol wird jeweils im Zustand des Automaten
gespeichert. Der \ac{PDA} für $L (\mathcal{G})$ mit Lookahead hat nun
folgende Komponenten:
\begin{itemize}
\item $Q = \Sigma\cup \{\varepsilon, \$\}$
\item $\qinit = [\Eps]$ (zu Beginn ist der Lookahead leer)
\item $F = [\$]$  (das Symbol $\$$ markiert das Ende der Eingabe)
\end{itemize}
und die Transitionsfunktion
\begin{align*}
  \delta ([\Eps], a, Z) & = \{([a], Z) \} & & \text{lade Lookahead} \\
  \delta ([a], \Eps, a) & = \{([\Eps], \varepsilon) \} && \text{match}
  \\
  \delta ([a], \Eps, A) & = \{([a], \beta) \mid A\to\beta\in P, a \in
  \mathit{first} (\beta) \} && \text{select}
\end{align*}
Der Automat startet in der Konfiguration $([\Eps], w\$, S\$)$.

\textbf{Beispiel}: Sei ein \ac{CFG} gegeben mit den Produktionen $S \to ( S )$ $ |$ $ a$. Für die Eingabe $(a)$ ergibt sich folgende Abarbeitung:
\begin{align*}
              & ([\Eps], (a), S\$ )   && \text{Lade Lookahead ,('}\\
  \Rightarrow & ([(], (a), S\$ )   && \text{Select: Da ,(' $\in first($ $(a)$ $ )$, wende $S \to (a)$ an}\\
  \Rightarrow & ([(], (a), (S)\$ ) && \text{Match ,('}\\
  \Rightarrow & ([\Eps], a), S)\$) \\
  \Rightarrow & ...
\end{align*}

\begin{Def}
  Sei $\mathcal{G} = (\Sigma, N, P, S)$ \ac{CFG} und $\beta \in
  (N\cup\Sigma)^*$
  \begin{align*}
    \mathit{first} (\beta) &= \{ a \in \Sigma \mid \exists w\in
    \Sigma^* , \beta \=>^* aw \} \cup \{\Eps \mid \beta \=>^* \Eps \}
  \end{align*}
\end{Def}

Spezifikation von $\mathit{first}(\beta)$
\begin{align*}
  \mathit{first} (\Eps) & = \{ \Eps \} \\
  \mathit{first} (a\beta) & = \{ a \} \\
  \mathit{first} (A\beta) & =
  \begin{cases}
    \mathit{first} (A) & \Eps \notin \mathit{first (A)} \\
    \mathit{first} (A) \setminus \{\Eps\} \cup \mathit{first} (\beta)
    & A\=>^* \Eps
  \end{cases} \\
  \mathit{first} (A) &= \bigcup  \{ \mathit{first} (\beta) \mid A \to
  \beta \in P \}
\end{align*}

\textbf{Algorithmus} zur Berechnung von $\mathit{first} (A)$ für alle $A\in N$

Sei $FI[A] \subseteq N$ ein Feld indiziert mit Nichtterminalsymbolen.

\begin{itemize}
\item[] For each $A \in N$: $FI[A] \gets \emptyset$
\item[] Repeat
  \begin{itemize}
  \item[] For each $A\in N$: $FI'[A] \gets FI[A]$
  \item[] For each $A \to \beta \in P$
    \begin{itemize}
    \item[] $FI[A] \gets FI[A] \cup \mathit{first}_{FI} (\beta)$
    \end{itemize}
  \end{itemize}
\item[] Until $\forall A\in N$: $FI'[A] = FI[A]$
\end{itemize}

Dabei ist
\begin{align*}
  \mathit{first}_{FI} (\Eps) & = \{ \Eps \} \\
  \mathit{first}_{FI} (a\beta) & = \{ a \} \\
  \mathit{first}_{FI} (A\beta) & =
  \begin{cases}
    FI[A] & \Eps \notin FI[A] \\
    FI[A] \setminus \{\Eps\} \cup \mathit{first}_{FI} (\beta)
    & \Eps\in FI[A]
  \end{cases} 
\end{align*}

\textbf{Beispiel}: Betrachte eine  Grammatik arithmetische Ausdrücke
mit Startsymbol $S$ und $N = \{E, T, F\}$, $\Sigma = \{a, -, *\}$ und Produktionen
\begin{align*}
  E & \to T E' & E' & \to -T E' \mid \varepsilon \\
  T & \to F T' & T' & \to *F T' \mid \varepsilon \\
  F & \to a
\end{align*}

Tabelle der Werte von $FI[A]$ wobei Zeile $i$ den Werten in $FI$ nach
dem $i$-ten Schleifendurchlauf entspricht.

\begin{displaymath}
  \begin{array}{c||c|c|c|c|c|}
    FI & E & E' & T & T' & F \\\hline
    0  & \emptyset & \emptyset & \emptyset & \emptyset & \emptyset \\
    1  & \emptyset & \{ -, \Eps \} & \emptyset & \{ *, \Eps \} & , \{a\} \\
    2  & \emptyset & \{ -, \Eps \} & \{a\} & \{ *, \Eps \} & , \{a\} \\
    3  & \{a\} & \{ -, \Eps \} & \{a\} & \{ *, \Eps \} & , \{a\} \\
    4  & \{a\} & \{ -, \Eps \} & \{a\} & \{ *, \Eps \} & , \{a\} \\
  \end{array}
\end{displaymath}

Ergebnis nach vier Durchläufen. 

Anmerkung: first ist nicht die vollständige Lösung des Problems. Für
den Lookahead müssen auch noch die Symbole betrachtet werden, die
\emph{nach} einem bestimmten Nichtterminal auftreten können. Mehr dazu
in Vorlesung Compilerbau. 
}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "Info_3_Skript_WS2016-17"
%%% End:(\dots)